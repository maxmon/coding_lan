##单个字符:

.          任意的一个字符

a|b        字符a或字符b

[afg]      a或者f或者g的一个字符        

[0-4]      0-4范围内的一个字符

[a-f]      a-f范围内的一个字符

[^m]       不是m的一个字符

\s         一个空格

\S         一个非空格

\d         [0-9]

\D         [^0-9]

\w         [0-9a-zA-Z]

\W         [^0-9a-zA-Z]

 

##重复

紧跟在单个字符之后，表示多个这样类似的字符

*         重复 >=0 次

+         重复 >=1 次

?         重复 0或者1 次

{m}       重复m次。比如说 a{4}相当于aaaa，再比如说[1-3]{2}相当于[1-3][1-3]

{m, n}    重复m到n次。比如说a{2, 5}表示a重复2到5次。小于m次的重复，或者大于n次的重复都不符合条件。

 

正则表达          相符的字符串举例

[0-9]{3,5}       9678

a?b              b

a+b              aaaaab

 

##位置

^         字符串的起始位置

$         字符串的结尾位置

 

正则表达          相符的字符串举例        不相符字符串

^ab.*c$          abeec               cabeec (如果用re.search(), 将无法找到。)

##返回控制

我们有可能对搜索的结果进行进一步精简信息。比如下面一个正则表达式：

output_(\d{4})

该正则表达式用括号()包围了一个小的正则表达式，\d{4}。 这个小的正则表达式被用于从结果中筛选想要的信息（在这里是四位数字）。这样被括号圈起来的正则表达式的一部分，称为群(group)。
我们可以m.group(number)的方法来查询群。group(0)是整个正则表达的搜索结果，group(1)是第一个群……

	import re
	m = re.search("output_(\d{4})", "output_1986.txt")
	print m.group(0), m.group(1)
 

我们还可以将群命名，以便更好地使用m.group查询:

	import re
	m = re.search("output_(?P<year>\d{4})", "output_1986.txt")   #(?P<name>...) 为group命名
	print(m.group("year"))